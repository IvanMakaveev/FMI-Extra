# C++ Синтаксис
## Първа програма на C++
Нека разгледаме първата ни програма на езика C++ при създаване на нов проект във Visual Studio:
```c++
#include <iostream>
using namespace std;

int main()
{
    cout << "Hello World";
}
```
На първият ред можем да забележим `#include <iostream>`. Това ни добавя външна функционалност към нашия код от библиотеката *iostream*. Тя позволява четенето и писането на конзолата посредством `cin` и `cout`. Това не е точно част от самия код, поради което не изисква да завъшрва с точка и запетая.

На следващия ред имаме `using namespace std;`. На този етап това също не ни интересува как точно работи, но общо взето ни спестява писането на `std::` преди всяко извикване на `cout` и `cin`. Без него кодът би изглеждал така:

```c++
#include <iostream>

int main()
{
    std::cout << "Hello World";
}
```

Можем да забележим, че в края на този 2-ри ред имаме **точка и запетая**. Този символ оказва **край на дадена операция/твърдение** в кода. В края на всеки израз имаме точка и запетая.

На следващия ред започва "тялото", където ние ще пишем нашият код. То се нарича **main функция** и от нея стартира нашата програма. За функции ще учим на по-късен етап, но най-важното в момента е да отбележим, че тя **започва с отваряне на фигурни скоби** `{` и **завършва със затваряне на фигурни скоби** `}`. Те учредяват даден **блок от код**. В случая, този блок ще принадлежи на нашата **main функция** и ще бъде изпълнен при стартиране на програмата.

Вътре в този блок можем да пишем нашата логика. В примера по-горе имаме само един ред, който гласи: ***изпечати на конзолата текстът 'Hello World'*** или написано с код:
```c++
cout << "Hello World";
```

## Променливи

Нека разгледаме как се създават променливи в езика C++. Те са еквивалент на променливите в математиката - пазят някаква стойност. Характеризират се с **тип**, който показва какви данни се съдържа в тях. Например:

```c++
int myNumber = 17;
```

Кодът по-горе създава променлива наиме `myNumber`, която е от тип *цяло число* - `int` и има стойност `17`. Може и да пропуснем даването на стойност, но тогава променливата ще приеме случайна стойност, каквато е намерила в паметта на компютъра.

```c++
int myNumber; 
```

Имаме няколко базови типа, които трябва да познаваме:
* Цяло число (`int`) - пази цяло число, което може да бъде положително или отрицателно (както и нула). Ако искаме да пазим само положителни числа, можем да използваме един друг целочислен тип - `unsigned int`.
```c++
int myNumber1 = -17; 
int myNumber2 = 24; 
```
* Дробно число (`double`) - пази дробно число. Разбира се, има и други типове за дробни число с по-малка или по-голяма прецизност на знака след десетичната запетая.
```c++
double myNumber1 = 27.24; 
double myNumber2 = 3.00001; 
```
* Символ (`char`) - пази символ, закодиран с дадено число (примерно 'a' е със стойност 97). Възможните символи, които могат да се запишат са от така наречената ASCII таблица: https://www.asciitable.com/
```c++
char mySymbol1 = 'Z'; 
char mySymbol2 = 97; // Ще бъде записан символ 'а' с код 97 
```
* Булева стойност / Истина-лъжа (`bool`) - приема две възможни стойности - `true` (истина, по стойност равна на 1) или `false` (лъжа, по стойност равна на 0). Използва се при логически проверки и операции.
```c++
bool isTrue = true; 
bool isFalse = 0; // Еквивалентно на използване на думата false 
```

Възможно е преобразуване между различните типове, но в зависимост от типовете, може да има или да няма загуба на информация. **Примерно**: от `bool` в `int` **няма да има загуба**, тъй като Булевите стойности са 0 или 1 и в целочислените можем да ги запазим без проблем. **Но обратното не е така**. Цялото число 127 при преобразуване в Булева стойност ще се превърне в 1, тъй като не можем да пазим стойност различна от 0 и 1.

## Оператори

Операторите представляват начин да използваме информацията, която сме съхранили в нашите променливи. Те се характеризират с три особености:
* Приоритет - кой оператор ще се изпълни преди останалите (примерно умножението е с приоритет пред събирането).
* Асоциативност - когато имаме два оператора с равен приоритет дали този най-отляво или този най-отдясно ще е първи.
* Позиция спрямо аргумента - дали е преди нашата стойност, между две стойности или след стойността (примерно събирането е между две стойности).

Нека разгледаме основните оператори:
* Аритметични - връщат числова стойност:
  * Събиране (<агумент1> `+` <агумент2>) - Нуждае се от два аргумента, чиито стойности той събира и връща като резултат. Ако те са от тип цяло число (`int`), операторът ни връща цяло число. Ако кой да е от тях е дробен тип (`double`) - връща дробно число.
  ```c++
  int first = 5;
  int second = 13;
  first + second // този израз ще има стойност 5 + 13 - цяло число
  first + 27 // този израз ще има стойност 5 + 27 - цяло число
  first + 27.01 // този израз ще има стойност 5 + 27.01 - дробно
  ```
  * Изваждане (<агумент1> `-` <агумент2>)
  * Умножение (<агумент1> `*` <агумент2>)
  * Деление (<агумент1> `/` <агумент2>) - При делението имаме особеност. Ако делим само цели числа, получаваме **ЗАДЪЛЖИТЕЛНО** цяло число. Дробната част **изцяло се маха** (не се закръгля, а просто се отрязва). Ако имаме поне едно дробно число, тогава резулатът ще бъде дробен.
  ```c++
  int first = 15;
  int second = 2;
  first / second // този израз ще има стойност 15 / 2 = 7 (без дробна част)
  first / 2.00 // този израз ще има стойност 15 / 2.00 = 7.5
  first / 0 // ГРЕШКА - невалидно делене
  ```
  * Деление с остатък / Модулно деление (<агумент1> `%` <агумент2>) - Това е особен оператор, който НЕ работи за дробни числа. Той приема две цели числа и връща остатъка при тяхното деление. Така заедно с оператора за деление (`/`) имаме **пълноценно деление** на цели стойности (единият дава частнотно, другият ни дава остатъка) 
  ```c++
  int first = 15;
  int second = 2;
  first / second // този израз ще има стойност 15 / 2 = 7 (без дробна част)
  first / 2.00 // този израз ще има стойност 15 / 2.00 = 7.5
  first / 0 // ГРЕШКА - невалидно делене
  ```
  * Пре-Инкрементация (`++`<аргумент - променлива>) и Пре-Декрементация (`--`<аргумент - променлива>) - **Инкрементация** и **Декрементация** означават съответно **увеличаване** и **намаляване**. Тези оператори увеличават или намаляват стойността на дадения аргумент с 1 и връщат **новата** стойност. Те ЗАДЪЛЖИТЕЛНО приемат променлива, тъй като директно влияят на стойността.
  ```c++
  int first = 15;
  int second = 2;
  ++first; // first става по стойност 16 и като резултат ни се връща 16
  --second; // second става по стойност 1 и като резултат ни се връща 1
  ```
  * Пост-Инкрементация (<аргумент - променлива>`++`) и Пост-Декрементация (<аргумент - променлива>`--`) - Тези оператори увеличават или намаляват стойността на дадения аргумент с 1 и връщат **старата** стойност. Те ЗАДЪЛЖИТЕЛНО приемат променлива, тъй като директно влияят на стойността.
  ```c++
  int first = 15;
  int second = 2;
  first++; // first става по стойност 16 и като резултат ни се връща 15
  second--; // second става по стойност 1 и като резултат ни се връща 2
  ```


* Сравнения - връщат Булева стойност (0 или 1)
  * Равенство (<агумент1> `==` <агумент2>) - Проверява се дали двата аргумента са равни
  * Различно (<агумент1> `!=` <агумент2>) - Проверява се дали двата аргумента са различни
  * Сравнения - по-малко (<агумент1> `<` <агумент2>) - Проверява се дали аргументът вляво е по-малък
  * Сравнения - по-голямо (<агумент1> `>` <агумент2>)
  * Сравнения - по-голямо или равно (<агумент1> `>=` <агумент2>)
  * Сравнения - по-малко или равно (<агумент1> `<=` <агумент2>)
  ```c++
  int first = 15;
  int second = 2;
  first == second // false
  first != second // true
  first > second // true
  first <= second // false
  'a' == 97 // true
  ```

* Логически - връщат Булева стойност (0 или 1)
  * Логическо отрицание (`!`<аргумент>) - връща отрицането на дадения аргумент. Ако той се приравнява на истина - връща лъжа. Ако се приравнява на лъжа - връща истина.
  ```c++
  bool isTrue = true;
  !isTrue // false
  !25 // false
  !0 // true
  ```
  * Логическо и (<аргумент1>`&&`<аргумент2>) - връща истина, ако и двата аргумента се приравняват на истина. Във всеки друг случай връща лъжа. АКО ПЪРВИЯТ АРГУМЕНТ Е ЛЪЖА, ОПЕРАТОРЪТ НЕ ПРОВЕРЯВА ВТОРИЯ.
  * Логическо или (<аргумент1>`||`<аргумент2>) - връща лъжа, ако и двата аргумента се приравняват на лъжа. Във всеки друг случай връща истина. АКО ПЪРВИЯТ АРГУМЕНТ Е ИСТИНА, ОПЕРАТОРЪТ НЕ ПРОВЕРЯВА ВТОРИЯ.
  ```c++
  bool isTrue = true;
  unsigned int grade = 6;
  grade == 6 && isTrue // true && true = true
  grade < 6 && isTrue // false && true = false
  isTrue || !grade // true || false = true
  0 || false // false || false = false
  true || grade++ // Тук тъй като първият аргумент е true, операторът || няма да пресметне втория аргумент, което означава, че grade няма да се увеличи от оператора ++
  ```

* За присвояване - задават стойност на променливите
  * Вече разгледахме как да извършване различни операции с променливите. Но до сега никъде не запазвахме резултата от тях. Операторите за присвояване (подобно на тези за пост- и пре-инкрементация) изискват **ЗАДЪЛЖИТЕЛНО** левият им аргумент да бъде **ПРОМЕНЛИВА**
  * Обикновено присвояване (<аргумент1 - променлива>`=`<аргумент2>) - задава стойността на променливата да бъде равна на израза вдясно.
  ```c++
  int number;
  number = 10; // Number приема стойност 10
  ```
  * Присвояване с аритметична операция събиране (<аргумент1 - променлива>`+=`<аргумент2>) - задава стойността на променливата да бъде равна на сбора на старата и израза вдясно.
  ```c++
  int number = 15;
  number += 10; // Number приема стойност 15 + 10 = 25
  ```
  * Присвояване с аритметична операция изваждане (<аргумент1 - променлива>`-=`<аргумент2>)
  ```c++
  int number = 15;
  number -= 10; // Number приема стойност 15 - 10 = 5
  ```
  * Аналогично за операторите `*=, /= и %=`, като не трябва да забравяме ограниченията поставени от самите оператори (не можем да делим с `%` дробни числа, а оператор `/` ни дава само цялата част при целочислено деление).

## Четене и писане от конзолата
Няма да навлизаме много в дълбочина как точно работят `cin` и `cout`, но общо взето се използват по следния начин:
* `cin >> <променлива>;` - записва в подадената променлива прочетените данни
* `cout << <променлива или израз>;` - изписва на конзолата резултата от променливата или израза
 
## Примерна задачка
  Да се напише програма, която прочита от конзолата три числа - страните на паралелепипед и пресмята обема. Да се изведе на конзолата този обем и да се провери дали е между 10 и 100 кубични единици.

  ```c++
  #include <iostream> // Това ни позволява да ползваме cin и cout
  using namespace std; // Улеснява ни писането (вместо std::cout -> cout)

  int main() // Нашата main функция - начало на програмата ни 
  {
    // Тук пишем нашият код:
    unsigned int sideA = 0; // Задаваме начална стойност 0
    unsigned int sideB = 0; // Не е задължително, но е добра практика
    unsigned int sideC = 0;

    cin >> sideA;
    cin >> sideB;
    cin >> sideC;

    // Смятаме обема
    unsigned int volume = sideA * sideB * sideC;

    // Извеждаме резултата
    cout << "The total volume is: ";
    cout << volume;

    // Използваме логическата проверка директно в изхода
    cout << "Is it between 10 and 100? ";
    cout << (volume >= 10 && volume <= 100); // Скоби за четимост 
  }
  ```

  ```c++
  #include <iostream>
  using namespace std;

  int main()
  {
    unsigned int sideA, sideB, sideC; // Декларираме променливи (можем да ги изредим със запетая, ако не искаме да ги пишем на отделен ред всяка. Накрая слагаме точка и запетая за край на израза)

    cin >> sideA >> sideB >> sideC; // Подобно на горния ред, cin и cout ни позволяват на един ред да извършим няколко извиквания, вместо да пишен на отделни редове

    unsigned int volume = sideA * sideB * sideC;

    cout << "The total volume is: " << volume << endl; // endl слага нов ред
    cout << "Is it between 10 and 100?" << (volume >= 10 && volume <= 100);
  }
  ```